{"version":3,"file":"team.b83b82127764aa80.js","mappings":"oBAGA,WACIA,KAAKC,eAAeC,eAIxB,MAAMC,EAAa,IAAIC,iBAAiB,CACxCC,GAAIC,SAASC,cAAc,SAC3BC,QAAQ,IAGRL,EAAWM,GAAG,SAAUP,cAAcQ,QAGtCR,cAAcS,cAAc,QAAS,CACrCC,SAAAA,CAAUC,GACN,OAAOC,UAAUC,OAASZ,EAAWa,SAASH,EAAO,EAAG,GAAKV,EAAWc,OAAOC,SAASD,OAAOE,CACnG,EACAC,sBAAqBA,KACV,CAACC,IAAK,EAAGC,KAAM,EAAGC,MAAOC,OAAOC,WAAYC,OAAQF,OAAOG,cAGtEC,QAAStB,SAASC,cAAc,SAASsB,MAAMC,UAAY,YAAc,UAGzE5B,cAAc6B,iBAAiB,WAAW,IAAM5B,EAAWO,WAG3DR,cAAc8B,UAId9B,cAAc6B,iBAAiB,WAAW,IAAM5B,EAAWO,WAG3DR,cAAc8B,SAEd,CACAC,GAGAC,MAAMC,cAAc,CAEhBC,MAAM,EACNC,KAAM,kCACNC,SAAU,IAGZJ,MAAMK,WAAW,SAAkC,CAEjDF,KAAM,kCACNC,SAAU,G","sources":["webpack:///./src/javascripts/team.js"],"sourcesContent":["import '../stylesheets/team.css';\r\n\r\n\r\nfunction locomotive(){\r\n    gsap.registerPlugin(ScrollTrigger);\r\n\r\n// Using Locomotive Scroll from Locomotive https://github.com/locomotivemtl/locomotive-scroll\r\n\r\nconst locoScroll = new LocomotiveScroll({\r\nel: document.querySelector(\".main\"),\r\nsmooth: true\r\n});\r\n// each time Locomotive Scroll updates, tell ScrollTrigger to update too (sync positioning)\r\nlocoScroll.on(\"scroll\", ScrollTrigger.update);\r\n\r\n// tell ScrollTrigger to use these proxy methods for the \".main\" element since Locomotive Scroll is hijacking things\r\nScrollTrigger.scrollerProxy(\".main\", {\r\nscrollTop(value) {\r\n    return arguments.length ? locoScroll.scrollTo(value, 0, 0) : locoScroll.scroll.instance.scroll.y;\r\n}, // we don't have to define a scrollLeft because we're only scrolling vertically.\r\ngetBoundingClientRect() {\r\n    return {top: 0, left: 0, width: window.innerWidth, height: window.innerHeight};\r\n},\r\n// LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\r\npinType: document.querySelector(\".main\").style.transform ? \"transform\" : \"fixed\"\r\n});\r\n// each time the window updates, we should refresh ScrollTrigger and then update LocomotiveScroll. \r\nScrollTrigger.addEventListener(\"refresh\", () => locoScroll.update());\r\n\r\n// after everything is set up, refresh() ScrollTrigger and update LocomotiveScroll because padding may have been added for pinning, etc.\r\nScrollTrigger.refresh();\r\n\r\n\r\n// each time the window updates, we should refresh ScrollTrigger and then update LocomotiveScroll. \r\nScrollTrigger.addEventListener(\"refresh\", () => locoScroll.update());\r\n\r\n// after everything is set up, refresh() ScrollTrigger and update LocomotiveScroll because padding may have been added for pinning, etc.\r\nScrollTrigger.refresh();\r\n\r\n}\r\nlocomotive()\r\n\r\n\r\nShery.mouseFollower({\r\n    //Parameters are optional.\r\n    skew: true,\r\n    ease: \"cubic-bezier(0.23, 1, 0.320, 1)\",\r\n    duration: 1,\r\n  });\r\n\r\n  Shery.makeMagnet(\".nav i\" /* Element to target.*/, {\r\n    //Parameters are optional.\r\n    ease: \"cubic-bezier(0.23, 1, 0.320, 1)\",\r\n    duration: 1,\r\n  });"],"names":["gsap","registerPlugin","ScrollTrigger","locoScroll","LocomotiveScroll","el","document","querySelector","smooth","on","update","scrollerProxy","scrollTop","value","arguments","length","scrollTo","scroll","instance","y","getBoundingClientRect","top","left","width","window","innerWidth","height","innerHeight","pinType","style","transform","addEventListener","refresh","locomotive","Shery","mouseFollower","skew","ease","duration","makeMagnet"],"sourceRoot":""}